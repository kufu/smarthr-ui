---
description: Figma Dev Mode MCP サーバーを使って画面を実装する際に使うルール
globs: 
alwaysApply: false
---
# SmartHR 汎用画面実装ルール

Figma Dev Mode MCP サーバーを使って SmartHR Design System で画面を実装する際の汎用実装ルール：

## 🔄 基本ワークフロー

1. **Figmaデータ取得**: MCPサーバーからデザインデータを取得
2. **デザイン詳細分析**: UIパターンとコンポーネントの状態を詳細に観察
3. **コンポーネント特定**: Figmaから必要なコンポーネントを識別  
4. **実装動的確認**: 特定されたコンポーネントの実装を確認
5. **適切なコード生成**: 実装仕様とデザイン詳細に基づいたコード生成

## 🚫 HTML要素 vs SmartHR UIコンポーネント優先原則

### 🔴 基本方針
SmartHR UIライブラリにコンポーネントが存在する場合、**必ず**SmartHR UIコンポーネントを使用し、生のHTML要素の使用を避ける。

### 🚫 具体的な禁止事項
- `<div>` + Tailwindクラス → 適切なレイアウトコンポーネント（`Stack`、`Cluster`、`Sidebar`等）を使用
- `<table>` → `<Table>` を使用
- `<th>` → `<Th>` を使用  
- `<td>` → `<Td>` を使用
- `<button>` → `<Button>` を使用
- `<input>` → `<Input>` を使用
- Tailwindクラスによる手動スタイリング → コンポーネントのデフォルトスタイルを活用

### ✅ 理由
1. **スタイルの統一性**: コンポーネント内部で統一されたスタイリング
2. **保守性**: デザインシステムの変更に自動対応
3. **アクセシビリティ**: コンポーネントレベルでのアクセシビリティ対応
4. **型安全性**: TypeScriptによる型チェック

## 🎨 Figmaデザイン詳細分析の重要ポイント

### 🔍 必須確認項目

#### 1. **テキスト階層とタイポグラフィ**
- **フォントサイズと重み**: 相対的なサイズ比較で適切な見出しレベルを判定
- **テキストの役割**: タイトル、見出し、本文、ラベル、キャプションの識別
- **色とコントラスト**: 強調レベルとセマンティック意味の判定

#### 2. **インタラクティブ要素の状態**
- **ボタンの種類**: プライマリ、セカンダリ、テキストボタン等の識別
- **アイコンの有無**: ドロップダウン、アクション、装飾アイコンの区別
- **状態表現**: デフォルト、ホバー、アクティブ、ディスアブル状態

#### 3. **コンテナとパネルの構造**
- **境界線と背景**: 視覚的なグループ化とセパレーション
- **開閉状態**: 展開可能なコンテンツの識別
- **スクロール領域**: オーバーフロー対応の必要性
- **🚨 コンテナ内部のpadding分析**: FigmaのXMLで子要素の`style[x]`と`style[y]`値を確認し、コンテナからのオフセット距離をpadding値として正確に反映する
- **🚨 Base/Container padding の責任分離**: コンテナ要素（Base、Container）の内部余白と、子コンポーネント（DefinitionList等）の内部gap管理は別の責任領域として明確に区別する

#### 4. **データ表示パターン**
- **🚨 テーブル構造検出時**: 必ずSmartHR UIの`Table`、`Th`、`Td`コンポーネントを使用
- **🚫 生のHTML禁止**: `<table>`、`<th>`、`<td>`要素は使用禁止
- **リスト構造**: 順序なし・順序ありリストの識別
- **カード形式**: グリッドレイアウトやカード要素の検出

#### 5. **レイアウト構造の判定**
- **水平配置**: 要素間の配置関係（左寄せ、中央、右寄せ、両端揃え）
- **垂直配置**: スタック構造やグリッド構造の識別
- **2カラム構造**: サイドバー型レイアウトの検出
- **🚨 中央寄せ要素**: 視覚的に中央配置されている要素の識別

#### 6. **Figma propsとメタデータ**
- **コンポーネントプロパティ**: Figmaで設定された明示的なプロパティ値
- **バリアント設定**: デザインで指定されたバリアント状態
- **レイヤー名**: セマンティック意味を持つレイヤー名の活用
- **🚨 StatusLabel type値の正確な反映**: `prop[type]="grey"`など、Figmaで指定された正確な値を使用
- **🚨 Button アイコンの正確な反映**: `prop[prefix_icon_value]="Icon/FaCloudDownloadAlt"`など、絵文字ではなく指定されたアイコンコンポーネントを使用
- **🚨 DefinitionList構造の判定**: `prop[type]="singleColumn"`が指定されている場合は`maxColumns={1}`を設定

#### 7. **🆕 視覚的配置の詳細確認**
- **要素の配置**: 各要素の相対的な位置関係（左・中央・右・両端）
- **余白とスペーシング**: 要素間の間隔とグループ化
- **整列**: 要素の揃え方向（上揃え、中央揃え、下揃え）
- **重要な配置パターン**: 特に見落としやすい中央配置要素の検出

#### 8. **🆕 構造的グルーピング**
- **論理的な要素の分離**: 関連する要素のグループ化
- **階層構造の反映**: Figmaの視覚的な階層をコード構造に反映
- **セクション単位の分割**: 機能的・意味的に異なるセクションの明確な分離

#### 9. **🚨 推測禁止・データ優先分析（必須）**
- **🚫 推測による実装の完全禁止**: 「〜っぽい」「〜だろう」による判断を一切行わない
- **📊 Figma XML数値データの必須確認**: `style[fontSize]`, `style[x]`, `style[y]`, `frame name`, `prop[*]` の全数値・文字列を必ず参照
- **📏 フォントサイズ階層の数値比較**: 全テキスト要素の `style[fontSize]` を抽出し、24px以上→PageHeading、19-23px→Heading、16-18px→Heading type="blockTitle" で判定
- **🎯 レイアウト方向の座標分析**: `style[x]`, `style[y]` から要素の相対位置を分析し、同じy座標→水平配置（Cluster）、異なるy座標で縦並び→縦積み（Stack）で判定
- **🔍 frame名とprop値の完全読取**: `<frame name="Cluster[0.5]">`, `prop[type]="singleColumn"` 等の明示的指示を見落とさない
- **✅ 一貫性チェックの強制**: 同種コンポーネント（DefinitionList, Heading等）の設定統一を必ず確認

## 🚀 実践的ワークフロー例

### Phase 1: Figmaデータ取得と詳細分析
```bash
# 1. Figmaからコード生成とイメージを並行取得
mcp_Figma_Dev_Mode_MCP_get_code
mcp_Figma_Dev_Mode_MCP_get_image

# 2. デザインの詳細確認
# - テキスト階層（フォントサイズ、重み、色）の比較分析
# - インタラクティブ要素（ボタン、フォーム等）の状態確認
# - コンテナ要素（パネル、カード等）の境界と背景確認
# - 🚨 テーブル・リスト構造の検出（必須確認）
# - 🚨 中央配置要素の検出（重要）
# - レイアウトパターン（水平・垂直配置）の判定
# - XML構造からコンポーネント関係を分析
# - Figma propsとバリアント設定の確認
# - 🆕 各要素の視覚的な配置位置を詳細に観察
# - 🆕 論理的なコンテンツグループの境界を確認
# - 🚨 コンテナのpadding値を正確に算出（子要素のstyle[x]/style[y]からオフセット距離を確認）
```

### Phase 2: コンポーネント実装確認
```bash
# 🚨 必須：推測禁止。全コンポーネントのソースコードを read_file で確認してからコード生成
# 3. FigmaのXMLから使用コンポーネントを抽出し、それらの実装をすべて確認
# - 検出された全コンポーネントの実装ファイルを読み込み
# - プロパティ仕様とデフォルト値の確認
# - バリアントとオプションの把握
# - 🚨 テーブル要素検出時は必ずTable、Th、Tdコンポーネントの実装を確認
# - 🚨 生のHTML要素使用を避け、SmartHR UIコンポーネント優先を徹底
# - レイアウトコンポーネント（Stack、Cluster、Sidebar等）の仕様確認
# - 🆕 デフォルト値を確認し、不要な明示化を避ける
```

### Phase 3: 実装仕様に基づくコード生成
```typescript
// 4. 正確なコンポーネント選択でコード生成
// セマンティック構造を考慮したコンテナ選択
<Container className="shr-bg-background">
  <Stack gap={1.5}>
    {/* フォントサイズに基づく適切な見出しコンポーネント選択 */}
    {/* 最大サイズ → PageHeading、中サイズ → Heading、小サイズ → Heading type="blockTitle" */}
    
    {/* 🆕 論理的なセクション分割 */}
    <Stack>
      {/* 通常のテキストコンテンツはpタグ使用 */}
      <p>説明文やコンテンツ</p>
      
      {/* デザインに応じた適切なコンポーネント選択 */}
      {/* 境界線があるコンテナ → InformationPanel等 */}
      {/* 開閉ボタンの有無でtogglableを判定 */}
    </Stack>
    
    <Stack>
      {/* レイアウト構造をFigma XMLに合わせる */}
      {/* 両端配置 → Cluster justify="space-between" */}
      {/* 2カラム → Sidebar */}
      {/* 縦積み → Stack */}
      
      {/* 🚨 テーブル構造は必ずSmartHR UIコンポーネントを使用 */}
      <Base overflow="auto">
        <Table>
          <thead>
            <tr>
              <Th>見出し1</Th>
              <Th>見出し2</Th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <Td>データ1</Td>
              <Td>データ2</Td>
            </tr>
          </tbody>
        </Table>
      </Base>
      
      {/* 🚨 視覚的に中央配置の場合は必ずCenterで囲む */}
      <Center>
        {/* 中央配置が必要な要素 */}
      </Center>
    </Stack>
  </Stack>
</Container>
```

## 📋 SmartHR UI コンポーネント選択指針

### 🏗️ コンテナコンポーネントの選択

#### 基本的な選択基準
```typescript
// ✅ メインコンテンツ領域（幅制御+中央配置が必要）
<Container className="shr-bg-background">
  {/* 画面のメインコンテンツ */}
</Container>

// ✅ 部分的なレイアウト（基本的な装飾のみ）
<Base overflow="auto">
  {/* 特定の装飾やオーバーフロー制御が必要な要素 */}
</Base>
```

#### 判断基準
- **画面全体のメインコンテンツ** → `Container`
- **特定の装飾・制御が必要** → `Base`
- **frame名にセマンティック意味** → 対応するコンポーネント選択

### 🎯 レイアウトコンポーネントの選択

#### レイアウトパターンの識別
```typescript
// ✅ 水平配置（両端揃え、中央揃え等）
<Cluster justify="space-between" align="center">
  <div>左側要素</div>
  <div>右側要素</div>
</Cluster>

// ✅ 2カラムレイアウト（サイドバー+メイン）
// 🚨 Sidebar使用時はサイドコンテンツに幅トークンを指定
<Sidebar>
  <Stack className="shr-basis-col2">サイドバーコンテンツ</Stack>
  <Stack>メインコンテンツ</Stack>
</Sidebar>

// ✅ 縦積みレイアウト
<Stack gap={1.5}>
  <div>要素1</div>
  <div>要素2</div>
</Stack>
```

#### 判断基準
- **水平配置で配置関係が重要** → `Cluster`
- **明確な2カラム構造** → `Sidebar`
- **縦積み構造** → `Stack`
- **複雑なグリッド** → グリッドコンポーネント検討

### 📝 テキストコンポーネントの選択

#### フォントサイズと重みによる判定
```typescript
// ✅ フォントサイズ比較による適切な選択
// 最大サイズ（画面タイトル）→ PageHeading
// 大サイズ（セクション見出し）→ Heading
// 中サイズ（ブロック見出し）→ Heading type="blockTitle"
// 小サイズ（ラベル等）→ Text または適切なコンポーネント

// 通常のコンテンツテキスト
<p>説明文やコンテンツはpタグを使用</p>

// 特定のスタイリングが必要なテキスト
<Text size="S" color="TEXT_GREY">ラベルテキスト</Text>
```

### 🔽 インタラクティブ要素の選択

#### デザインからの状態判定
```typescript
// ✅ ボタンの種類をデザインから判定
// プライマリ色 → Button（デフォルト）
// セカンダリ色・アウトライン → Button variant="secondary"
// ドロップダウン矢印 → DropdownMenuButton
// テキストのみ → TextButton

// 🚨 「〜に戻る」リンクは必ずUpwardLinkを使用
// 画面上部の「一覧に戻る」「前のページに戻る」等のパターン
<UpwardLink href="#">一覧に戻る</UpwardLink>

// フォーム要素もデザインに応じて選択
<Input type="text" />
<Checkbox />
<RadioButton />
```

### 📊 データ表示コンポーネントの選択

#### 🚨 テーブル vs 生のHTML（重要）
```typescript
// ✅ SmartHR UIコンポーネントを使用（必須）
<Table>
  <thead>
    <tr>
      <Th>見出し</Th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <Td>データ</Td>
    </tr>
  </tbody>
</Table>

// 🚫 生のHTML要素を使用（禁止）
<table>
  <thead>
    <tr>
      <th>見出し</th>
    </tr>
  </thead>
</table>
```

#### その他のデータ表示
```typescript
// リスト構造の場合
<ul>
  <li>項目1</li>
  <li>項目2</li>
</ul>

// カード形式の場合
<Stack gap={1}>
  {items.map(item => (
    <Base key={item.id} className="card-style">
      {/* カードコンテンツ */}
    </Base>
  ))}
</Stack>
```

### 🆕 デフォルト値の活用

#### 不要な明示化を避ける
```typescript
// ✅ デフォルト値を活用
<Button>ボタン</Button>                     // variant="primary"は省略
<Heading>見出し</Heading>                   // type="sectionTitle"は省略
<Text>テキスト</Text>                       // size="M"は省略
<DefinitionList>                            // maxColumns、termStyleType等は省略
  <DefinitionListItem term="項目">値</DefinitionListItem>
</DefinitionList>

// ❌ 不要な明示化
<Button variant="primary">ボタン</Button>
<Heading type="sectionTitle">見出し</Heading>
<Text size="M">テキスト</Text>
<DefinitionList maxColumns={1} termStyleType="subBlockTitle">  // 不要な指定
  <DefinitionListItem term="項目" termStyleType="subSubBlockTitle">値</DefinitionListItem>
</DefinitionList>

// 🚨 ただし、Figmaで明示的に指定されている場合は従う
<StatusLabel type="grey">成功</StatusLabel>  // Figmaでprop[type]="grey"が指定されている場合
<Button variant="secondary" prefix={<FaCloudArrowDownIcon />}>  // Figmaでアイコンが指定されている場合
  ダウンロード
</Button>
<DefinitionList maxColumns={1}>  // Figmaでprop[type]="singleColumn"が指定されている場合
  <DefinitionListItem term="項目">値</DefinitionListItem>
</DefinitionList>
```

## 🔍 動的確認チェックリスト

コード生成前に以下を確認：

### 📋 Figmaデザイン確認
- [ ] **🚨 Figma XML数値データの完全確認**（推測禁止・データ優先の徹底）
  - [ ] 全テキスト要素の `style[fontSize]` を抽出・比較済み
  - [ ] 全要素の `style[x]`, `style[y]` から配置方向を分析済み
  - [ ] `frame name`（Cluster, Stack, Sidebar等）を確認済み
  - [ ] `prop[*]` 値を全て読み取り済み
- [ ] **テキスト階層を詳細に確認**（フォントサイズ、重み、色の相対比較）
- [ ] **インタラクティブ要素の状態を確認**（ボタン種類、アイコン、状態）
- [ ] **コンテナ要素の境界と背景を確認**（パネル、カード等の視覚的区分）
- [ ] **🚨 テーブル・リスト構造の検出**（データ表示パターンの識別）
- [ ] **🚨 中央配置要素の検出**（視覚的に中央に配置されている要素）
- [ ] **レイアウトパターンの判定**（水平・垂直配置、2カラム等）
- [ ] **XML構造からコンポーネント関係を分析**
- [ ] **Figma propsとバリアント設定を確認**
- [ ] **🆕 各要素の視覚的な配置を詳細に確認**（左・中央・右・両端の配置）
- [ ] **🆕 コンテンツの論理的なグループ境界を確認**
- [ ] **🚨 コンテナのpadding値を正確に算出**（子要素のstyle[x]/style[y]からオフセット距離を確認）

### 実装確認
- [ ] **検出された全コンポーネントの実装ファイルを確認済み**
- [ ] **🚨 テーブル要素使用時はTable、Th、Tdコンポーネントの実装を確認済み**
- [ ] **🚫 生のHTML要素ではなくSmartHR UIコンポーネント使用を確認**
- [ ] **レイアウトコンポーネント（Stack、Cluster、Sidebar等）の実装確認**
- [ ] **型定義からプロパティの仕様を把握済み**  
- [ ] **🆕 デフォルト値を確認し、不要な明示を避けている**
- [ ] **利用可能なバリアント・オプションを把握済み**

### コード品質
- [ ] **import順序が正しい**（React hooks → smarthr-ui）
- [ ] **インラインスタイルを使用していない**
- [ ] **適切なクラス名を使用している**
- [ ] **Figmaデザインに忠実な実装**
- [ ] **🆕 論理的な要素グループが適切に分離されている**

### 💡 コンポーネント選択確認
- [ ] **コンテナコンポーネントを正しく選択**（Container vs Base）
- [ ] **🚨 データ表示コンポーネントを正しく選択**（必ずTable使用）
- [ ] **レイアウトコンポーネントを正しく選択**（Cluster vs Sidebar vs Stack）
- [ ] **テキストコンポーネントを正しく選択**（階層とサイズに応じて）
- [ ] **インタラクティブ要素を正しく選択**（デザインの状態に応じて）
- [ ] **🆕 テキスト要素を正しく選択**（Text vs p タグ）
- [ ] **🆕 視覚的配置（特に中央揃え）を正確に再現**

## 🎯 よくある間違いと対策

### ❌ よくある間違い
1. **フォントサイズ比較を怠る** → 相対的なサイズ比較で適切な見出しレベルを判定すべき
2. **インタラクティブ要素の状態を見落とす** → デザインの詳細（アイコン、色、状態）を確認すべき
3. **コンテナの境界を無視** → 視覚的なグループ化とセパレーションを正確に把握すべき
4. **🚨 中央配置要素の見落とし** → 視覚的に中央配置されている要素はCenterコンポーネント必須
5. **レイアウトパターンの誤認識** → XML構造と視覚的配置の両方を確認すべき
6. **Figma propsを無視** → 明示的に設定されたプロパティ値を優先すべき
7. **コンポーネント実装確認を怠る** → 使用するコンポーネントの実装を必ず確認すべき
8. **🚨 生のHTML要素（table、th、td等）を使用** → SmartHR UIコンポーネントを使用すべき
9. **🆕 デフォルト値の過度な明示化** → 不要な指定を省略すべき
10. **🆕 テキスト要素の選択ミス** → 通常のコンテンツはpタグ、特殊なスタイリングはTextコンポーネント
11. **🆕 論理的なグループ分けの不備** → 関連要素を適切にグループ化すべき
12. **🚨 StatusLabel type値の読み取りミス** → Figmaのprop[type]値を正確に反映すべき（grey/green/blue/red等）
13. **🚨 Button アイコンの実装ミス** → 絵文字ではなくFigmaで指定されたSmartHR UIアイコンコンポーネントを使用すべき
14. **🚨 DefinitionList設定の見落とし** → Figmaでprop[type]="singleColumn"が指定されている場合はmaxColumns={1}を設定すべき
15. **🚨 コンテナpadding の見落とし** → FigmaのXMLで子要素のstyle[x]/style[y]値からコンテナの内部paddingを正確に算出すべき
16. **🚨 フォントサイズ階層の推測判定** → 24px→PageHeading、19px→Heading等、数値データで正確に判定すべき
17. **🚨 レイアウト方向の視覚的判断ミス** → frame名とxy座標データで水平配置（Cluster）vs縦積み（Stack）を正確に判定すべき
18. **🚨 同種コンポーネントの設定不統一** → DefinitionListのmaxColumns等、同じ種類のコンポーネントは一貫した設定にすべき

### ✅ 対策
1. **デザインの詳細を多角的に分析**
2. **コンポーネントの適用パターンを理解**
3. **実装ファイルで仕様を確認**
4. **SmartHR UI の設計思想を理解**
5. **Figma データの構造を正確に解析**
6. **🚨 生のHTML要素使用を完全に避け、コンポーネント優先を確立**
7. **🆕 デザインの視覚的配置を詳細に分析**
8. **🆕 論理的なコンテンツ構造を適切に反映**
9. **🚨 推測による実装を完全に禁止し、データ優先の分析を徹底**
10. **🚨 Figma XMLの数値・文字列データを必ず参照して正確な判定を実施**

---

**詳細なデザイン分析と動的確認により、どんなFigmaデザインにも対応可能な正確で保守性の高いコード生成を実現します。**